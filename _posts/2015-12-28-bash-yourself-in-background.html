---
layout: post
title: Bash yourself in the background!
date: '2015-12-28T22:51:00.000-08:00'
author: Mark J. Lehman
tags:
- screen
- ubuntu
- bash
modified_time: '2015-12-28T22:51:00.845-08:00'
blogger_id: tag:blogger.com,1999:blog-4459370175540830177.post-8709374405299790085
blogger_orig_url: http://spaghettirefactory.blogspot.com/2015/12/bash-yourself-in-background.html
---

There are many occasions for wanting to run bash scripts in the background. The two that jump out at me are startup scripts and scripts to be run while SSH-ed into a remote server. This post deals mainly with the latter, though it should work for both.<br /><br />First, create a bash script you want to run. I wanted to monitor the memory of a running EC2 server instance to ensure we didn’t have memory leaking from our app, so here’s my bash script:<br /><pre class="prettyprint"><code class=" hljs livecodeserver"><span class="hljs-comment"><br /></span></code></pre><pre class="prettyprint"><code class=" hljs livecodeserver"><span class="hljs-comment"># log/memory_profiler.sh</span><br /><span class="hljs-keyword">while</span> <span class="hljs-constant">true</span><br /> <span class="hljs-built_in">do</span><br />    <span class="hljs-built_in">date</span> <span class="hljs-number">2</span>&gt;&amp;<span class="hljs-number">1</span> | tee -<span class="hljs-operator">a</span> /srv/application/my_application/<span class="hljs-built_in">log</span>/memory<br />    free -m <span class="hljs-number">2</span>&gt;&amp;<span class="hljs-number">1</span> | tee -<span class="hljs-operator">a</span> /srv/application/my_application/<span class="hljs-built_in">log</span>/memory<br />     sleep <span class="hljs-number">1</span><br /> done</code></pre><br />This writes the current datetime and the current memory profile to a log file in my app’s directory.<br /><br />Then, I wanted to run this script from a detached shell session so that when I closed my SSH connection, it would continue running, and also so that I could continue working within the open shell session. To do this, I use a tool called “screen.” Here’s my command:<br /><pre class="prettyprint"><code class=" hljs lasso"><br /></code></pre><pre class="prettyprint"><code class=" hljs lasso">screen <span class="hljs-attribute">-d</span> <span class="hljs-attribute">-m</span> <span class="hljs-attribute">-S</span> <span class="hljs-string">"Memory Profiler"</span> bash <span class="hljs-keyword">log</span>/memory_profiler<span class="hljs-built_in">.</span>sh</code></pre><br />Here’s what’s happening: We run the bash script in a detached (<code>-d</code>) shell session, named (<code>-S</code>) “Memory Profiler”. The <code>-m</code> flag ensures a new shell session is created, regardless of where the <code>screen</code> command is called.<br /><br />Simple enough, right? Then, to view what’s going on with this detached <code>screen</code> session, you just have to reattach the shell session. If you only have one <code>screen</code> running, enter<br /><pre class="prettyprint"><code class=" hljs lasso"><br /></code></pre><pre class="prettyprint"><code class=" hljs lasso">screen <span class="hljs-attribute">-r</span></code></pre><br />If multiple, you’ll have to specify the named session.<br /><pre class="prettyprint"><code class=" hljs lasso"><br /></code></pre><pre class="prettyprint"><code class=" hljs lasso">screen <span class="hljs-attribute">-r</span> <span class="hljs-string">"Memory Profiler"</span></code></pre><br />Exit as normal using <code>ctrl+c</code> or typing <code>exit</code>.<br /><br />If you want to get really fancy, you can run this on a schedule - <a href="{{ site.baseurl }}/2015-12-01-bash-yourself-on-schedule" rel="nofollow" target="">something I've written about previously</a>.<br /><br />(Lots of good info in the <a href="https://www.gnu.org/software/screen/manual/screen.html" rel="nofollow" target="_blank">screen docs</a>.)